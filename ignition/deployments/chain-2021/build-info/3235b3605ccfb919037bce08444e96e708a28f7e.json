{
  "_format": "hh3-sol-build-info-1",
  "id": "3235b3605ccfb919037bce08444e96e708a28f7e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Game.sol": "project/contracts/Game.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Game.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/// @title Ronin Rivals - Samurai Battle Game\n/// @notice A turn-based battle game where Samurai characters fight and improve their skills\ncontract RoninRivals {\n    /// @notice Minimum bet amount for battles\n    uint256 public constant MINIMUM_BET = 0.01 ether;\n    \n    /// @notice Maximum bet amount for battles\n    uint256 public constant MAXIMUM_BET = 1 ether;\n    \n    /// @notice Experience points needed to level up\n    uint256 public constant XP_PER_LEVEL = 100;\n    \n    /// @notice Skill points gained per level\n    uint256 public constant SKILL_POINTS_PER_LEVEL = 3;\n\n    /// @notice Samurai character structure\n    struct Samurai {\n        string name;\n        uint256 level;\n        uint256 experience;\n        uint256 skillPoints;\n        uint256 strength;      // Attack power\n        uint256 defense;       // Damage reduction\n        uint256 speed;         // Turn order and dodge chance\n        uint256 health;        // Max HP\n        uint256 battlesWon;\n        uint256 battlesLost;\n        bool exists;\n    }\n\n    /// @notice Battle structure\n    struct Battle {\n        address player1;\n        address player2;\n        uint256 bet;\n        uint256 player1Health;\n        uint256 player2Health;\n        bool isActive;\n        address currentTurn;\n        uint256 turnCount;\n    }\n\n    /// @notice Mapping of player addresses to their Samurai\n    mapping(address => Samurai) public samurais;\n    \n    /// @notice Mapping of battle IDs to battle data\n    mapping(uint256 => Battle) public battles;\n    \n    /// @notice Current battle ID counter\n    uint256 public battleIdCounter;\n    \n    /// @notice Owner address\n    address private owner;\n\n    /// @notice Events\n    event SamuraiCreated(address indexed player, string name);\n    event BattleStarted(uint256 indexed battleId, address player1, address player2, uint256 bet);\n    event BattleTurn(uint256 indexed battleId, address player, uint256 damage, uint256 remainingHealth);\n    event BattleEnded(uint256 indexed battleId, address winner, address loser, uint256 reward);\n    event SkillUpgraded(address indexed player, string stat, uint256 newValue);\n\n    /// @notice Sets the contract deployer as the owner\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    /// @notice Ensures that only the owner can call the function\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    /// @notice Ensures the player has a Samurai\n    modifier hasSamurai() {\n        require(samurais[msg.sender].exists, \"You must create a Samurai first\");\n        _;\n    }\n\n    /// @notice Creates a new Samurai character\n    /// @param _name The name of the Samurai\n    function createSamurai(string memory _name) public {\n        require(!samurais[msg.sender].exists, \"Samurai already exists\");\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\n        \n        samurais[msg.sender] = Samurai({\n            name: _name,\n            level: 1,\n            experience: 0,\n            skillPoints: 0,\n            strength: 10,\n            defense: 5,\n            speed: 8,\n            health: 100,\n            battlesWon: 0,\n            battlesLost: 0,\n            exists: true\n        });\n        \n        emit SamuraiCreated(msg.sender, _name);\n    }\n\n    /// @notice Upgrades a Samurai's stat using skill points\n    /// @param _stat The stat to upgrade (0=strength, 1=defense, 2=speed, 3=health)\n    function upgradeStat(uint8 _stat) public hasSamurai {\n        Samurai storage samurai = samurais[msg.sender];\n        require(samurai.skillPoints > 0, \"No skill points available\");\n        require(_stat < 4, \"Invalid stat\");\n        \n        samurai.skillPoints--;\n        \n        if (_stat == 0) {\n            samurai.strength += 2;\n            emit SkillUpgraded(msg.sender, \"strength\", samurai.strength);\n        } else if (_stat == 1) {\n            samurai.defense += 1;\n            emit SkillUpgraded(msg.sender, \"defense\", samurai.defense);\n        } else if (_stat == 2) {\n            samurai.speed += 1;\n            emit SkillUpgraded(msg.sender, \"speed\", samurai.speed);\n        } else if (_stat == 3) {\n            samurai.health += 10;\n            emit SkillUpgraded(msg.sender, \"health\", samurai.health);\n        }\n    }\n\n    /// @notice Starts a battle with another player\n    /// @param _opponent The address of the opponent\n    function startBattle(address _opponent) public payable hasSamurai {\n        require(_opponent != msg.sender, \"Cannot battle yourself\");\n        require(samurais[_opponent].exists, \"Opponent must have a Samurai\");\n        require(msg.value >= MINIMUM_BET && msg.value <= MAXIMUM_BET, \"Invalid bet amount\");\n        require(address(this).balance >= msg.value * 2, \"Contract needs more funds\");\n        \n        uint256 battleId = battleIdCounter++;\n        \n        battles[battleId] = Battle({\n            player1: msg.sender,\n            player2: _opponent,\n            bet: msg.value,\n            player1Health: samurais[msg.sender].health,\n            player2Health: samurais[_opponent].health,\n            isActive: true,\n            currentTurn: msg.sender, // Player1 starts\n            turnCount: 0\n        });\n        \n        emit BattleStarted(battleId, msg.sender, _opponent, msg.value);\n    }\n\n    /// @notice Executes a turn in an active battle\n    /// @param _battleId The ID of the battle\n    function executeTurn(uint256 _battleId) public {\n        Battle storage battle = battles[_battleId];\n        require(battle.isActive, \"Battle is not active\");\n        require(msg.sender == battle.currentTurn, \"Not your turn\");\n        \n        address attacker = msg.sender;\n        address defender = (attacker == battle.player1) ? battle.player2 : battle.player1;\n        \n        // Calculate damage\n        uint256 damage = calculateDamage(attacker, defender);\n        \n        // Apply damage\n        if (attacker == battle.player1) {\n            battle.player2Health = (battle.player2Health > damage) ? battle.player2Health - damage : 0;\n        } else {\n            battle.player1Health = (battle.player1Health > damage) ? battle.player1Health - damage : 0;\n        }\n        \n        battle.turnCount++;\n        \n        emit BattleTurn(_battleId, attacker, damage, \n            (attacker == battle.player1) ? battle.player2Health : battle.player1Health);\n        \n        // Check if battle is over\n        if (battle.player1Health == 0 || battle.player2Health == 0) {\n            endBattle(_battleId);\n        } else {\n            // Switch turns\n            battle.currentTurn = (battle.currentTurn == battle.player1) ? battle.player2 : battle.player1;\n        }\n    }\n\n    /// @notice Calculates damage for an attack\n    /// @param _attacker The attacking player\n    /// @param _defender The defending player\n    /// @return The damage dealt\n    function calculateDamage(address _attacker, address _defender) internal view returns (uint256) {\n        Samurai storage attackerSamurai = samurais[_attacker];\n        Samurai storage defenderSamurai = samurais[_defender];\n        \n        uint256 baseDamage = attackerSamurai.strength;\n        uint256 defense = defenderSamurai.defense;\n        \n        // Simple damage formula: base damage - defense (minimum 1)\n        uint256 damage = (baseDamage > defense) ? baseDamage - defense : 1;\n        \n        // Add some randomness (0-20% bonus)\n        uint256 randomBonus = uint256(keccak256(abi.encodePacked(block.timestamp, _attacker))) % 21;\n        damage = damage + (damage * randomBonus / 100);\n        \n        return damage;\n    }\n\n    /// @notice Ends a battle and distributes rewards\n    /// @param _battleId The ID of the battle\n    function endBattle(uint256 _battleId) internal {\n        Battle storage battle = battles[_battleId];\n        address winner = (battle.player1Health > 0) ? battle.player1 : battle.player2;\n        address loser = (winner == battle.player1) ? battle.player2 : battle.player1;\n        \n        // Update battle stats\n        samurais[winner].battlesWon++;\n        samurais[loser].battlesLost++;\n        \n        // Award experience and check for level up\n        awardExperience(winner, 50);\n        awardExperience(loser, 10);\n        \n        // Transfer winnings\n        payable(winner).transfer(battle.bet * 2);\n        \n        battle.isActive = false;\n        \n        emit BattleEnded(_battleId, winner, loser, battle.bet * 2);\n    }\n\n    /// @notice Awards experience points and handles level ups\n    /// @param _player The player to award experience to\n    /// @param _xp The amount of experience to award\n    function awardExperience(address _player, uint256 _xp) internal {\n        Samurai storage samurai = samurais[_player];\n        samurai.experience += _xp;\n        \n        // Check for level up\n        uint256 requiredXP = samurai.level * XP_PER_LEVEL;\n        if (samurai.experience >= requiredXP) {\n            samurai.level++;\n            samurai.skillPoints += SKILL_POINTS_PER_LEVEL;\n            samurai.experience -= requiredXP;\n        }\n    }\n\n    /// @notice Gets a player's Samurai data\n    /// @param _player The player address\n    /// @return The Samurai struct\n    function getSamurai(address _player) public view returns (Samurai memory) {\n        return samurais[_player];\n    }\n\n    /// @notice Gets battle data\n    /// @param _battleId The battle ID\n    /// @return The Battle struct\n    function getBattle(uint256 _battleId) public view returns (Battle memory) {\n        return battles[_battleId];\n    }\n\n    /// @notice Allows the owner to withdraw contract funds\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds to withdraw\");\n        payable(owner).transfer(balance);\n    }\n}"
      }
    }
  }
}