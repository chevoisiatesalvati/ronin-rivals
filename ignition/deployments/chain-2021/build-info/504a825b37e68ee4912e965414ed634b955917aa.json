{
  "_format": "hh3-sol-build-info-1",
  "id": "504a825b37e68ee4912e965414ed634b955917aa",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/RoninRivals.sol": "project/contracts/RoninRivals.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/RoninRivals.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\n/// @title Ronin Rivals - Samurai Battle Game\n/// @notice A turn-based battle game where Samurai characters fight and improve their skills\ncontract RoninRivals {\n    /// @notice Minimum bet amount for battles\n    uint256 public constant MINIMUM_BET = 0.01 ether;\n    \n    /// @notice Maximum bet amount for battles\n    uint256 public constant MAXIMUM_BET = 1 ether;\n    \n    /// @notice Experience points needed to level up\n    uint256 public constant XP_PER_LEVEL = 100;\n    \n    /// @notice Skill points gained per level\n    uint256 public constant SKILL_POINTS_PER_LEVEL = 3;\n\n    /// @notice Samurai character structure\n    struct Samurai {\n        string name;\n        uint256 level;\n        uint256 experience;\n        uint256 skillPoints;\n        uint256 strength;      // Attack power\n        uint256 defense;       // Damage reduction\n        uint256 speed;         // Turn order and dodge chance\n        uint256 health;        // Max HP\n        uint256 battlesWon;\n        uint256 battlesLost;\n        bool exists;\n    }\n\n    /// @notice Battle structure\n    struct Battle {\n        address challenger;    // Player who initiated the challenge\n        address opponent;      // Player who was challenged\n        uint256 bet;          // Bet amount (both players pay this)\n        uint256 challengerHealth;\n        uint256 opponentHealth;\n        bool isActive;        // True when battle is ongoing\n        bool isAccepted;      // True when opponent accepted the challenge\n        address currentTurn;  // Whose turn it is\n        uint256 turnCount;\n    }\n\n    /// @notice Mapping of player addresses to their Samurai\n    mapping(address => Samurai) public samurais;\n    \n    /// @notice Mapping of battle IDs to battle data\n    mapping(uint256 => Battle) public battles;\n    \n    /// @notice Current battle ID counter\n    uint256 public battleIdCounter;\n    \n    /// @notice Owner address\n    address private owner;\n\n    /// @notice Events\n    event SamuraiCreated(address indexed player, string name);\n    event BattleChallenged(uint256 indexed battleId, address challenger, address opponent, uint256 bet);\n    event BattleAccepted(uint256 indexed battleId, address opponent);\n    event BattleTurn(uint256 indexed battleId, address player, uint256 damage, uint256 remainingHealth);\n    event CriticalHit(uint256 indexed battleId, address player, uint256 damage);\n    event BattleEnded(uint256 indexed battleId, address winner, address loser, uint256 reward);\n    event SkillUpgraded(address indexed player, string stat, uint256 newValue);\n    event ContractFunded(address indexed funder, uint256 amount);\n\n    /// @notice Sets the contract deployer as the owner\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    /// @notice Ensures that only the owner can call the function\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    /// @notice Ensures the player has a Samurai\n    modifier hasSamurai() {\n        require(samurais[msg.sender].exists, \"You must create a Samurai first\");\n        _;\n    }\n\n    /// @notice Creates a new Samurai character\n    /// @param _name The name of the Samurai\n    function createSamurai(string memory _name) public {\n        require(!samurais[msg.sender].exists, \"Samurai already exists\");\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\n        \n        samurais[msg.sender] = Samurai({\n            name: _name,\n            level: 1,\n            experience: 0,\n            skillPoints: 0,\n            strength: 10,\n            defense: 10,\n            speed: 10,\n            health: 20,\n            battlesWon: 0,\n            battlesLost: 0,\n            exists: true\n        });\n        \n        emit SamuraiCreated(msg.sender, _name);\n    }\n\n    /// @notice Upgrades a Samurai's stat using skill points\n    /// @param _stat The stat to upgrade (0=strength, 1=defense, 2=speed, 3=health)\n    function upgradeStat(uint8 _stat) public hasSamurai {\n        Samurai storage samurai = samurais[msg.sender];\n        require(samurai.skillPoints > 0, \"No skill points available\");\n        require(_stat < 4, \"Invalid stat\");\n        \n        samurai.skillPoints--;\n        \n        if (_stat == 0) {\n            samurai.strength += 2;\n            emit SkillUpgraded(msg.sender, \"strength\", samurai.strength);\n        } else if (_stat == 1) {\n            samurai.defense += 1;\n            emit SkillUpgraded(msg.sender, \"defense\", samurai.defense);\n        } else if (_stat == 2) {\n            samurai.speed += 1;\n            emit SkillUpgraded(msg.sender, \"speed\", samurai.speed);\n        } else if (_stat == 3) {\n            samurai.health += 10;\n            emit SkillUpgraded(msg.sender, \"health\", samurai.health);\n        }\n    }\n\n    /// @notice Challenges another player to a battle\n    /// @param _opponent The address of the opponent\n    function challengeBattle(address _opponent) public payable hasSamurai {\n        require(_opponent != msg.sender, \"Cannot challenge yourself\");\n        require(samurais[_opponent].exists, \"Opponent must have a Samurai\");\n        require(msg.value >= MINIMUM_BET && msg.value <= MAXIMUM_BET, \"Invalid bet amount\");\n        \n        uint256 battleId = battleIdCounter++;\n        \n        battles[battleId] = Battle({\n            challenger: msg.sender,\n            opponent: _opponent,\n            bet: msg.value,\n            challengerHealth: samurais[msg.sender].health,\n            opponentHealth: samurais[_opponent].health,\n            isActive: false, // Battle not active until accepted\n            isAccepted: false, // Challenge not yet accepted\n            currentTurn: msg.sender, // Challenger starts\n            turnCount: 0\n        });\n        \n        emit BattleChallenged(battleId, msg.sender, _opponent, msg.value);\n    }\n\n    /// @notice Accepts a battle challenge\n    /// @param _battleId The ID of the battle to accept\n    function acceptBattle(uint256 _battleId) public payable {\n        Battle storage battle = battles[_battleId];\n        require(msg.sender == battle.opponent, \"Only the challenged player can accept\");\n        require(!battle.isAccepted, \"Battle already accepted\");\n        require(!battle.isActive, \"Battle already active\");\n        require(msg.value == battle.bet, \"Must pay the same bet amount\");\n        \n        battle.isAccepted = true;\n        battle.isActive = true;\n        \n        emit BattleAccepted(_battleId, msg.sender);\n    }\n\n    /// @notice Executes a turn in an active battle\n    /// @param _battleId The ID of the battle\n    function executeTurn(uint256 _battleId) public {\n        Battle storage battle = battles[_battleId];\n        require(battle.isActive, \"Battle is not active\");\n        require(battle.isAccepted, \"Battle must be accepted first\");\n        require(msg.sender == battle.currentTurn, \"Not your turn\");\n        \n        address attacker = msg.sender;\n        address defender = (attacker == battle.challenger) ? battle.opponent : battle.challenger;\n        \n        // Calculate damage\n        (uint256 damage, bool isCriticalHit) = calculateDamage(attacker, defender);\n        \n        // Apply damage\n        if (attacker == battle.challenger) {\n            battle.opponentHealth = (battle.opponentHealth > damage) ? battle.opponentHealth - damage : 0;\n        } else {\n            battle.challengerHealth = (battle.challengerHealth > damage) ? battle.challengerHealth - damage : 0;\n        }\n        \n        battle.turnCount++;\n        \n        emit BattleTurn(_battleId, attacker, damage, \n            (attacker == battle.challenger) ? battle.opponentHealth : battle.challengerHealth);\n        \n        // Emit critical hit event if it occurred\n        if (isCriticalHit) {\n            emit CriticalHit(_battleId, attacker, damage);\n        }\n        \n        // Check if battle is over\n        if (battle.challengerHealth == 0 || battle.opponentHealth == 0) {\n            endBattle(_battleId);\n        } else {\n            // Switch turns\n            battle.currentTurn = (battle.currentTurn == battle.challenger) ? battle.opponent : battle.challenger;\n        }\n    }\n\n    /// @notice Calculates damage for an attack\n    /// @param _attacker The attacking player\n    /// @param _defender The defending player\n    /// @return The damage dealt\n    /// @return Whether a critical hit occurred\n    function calculateDamage(address _attacker, address _defender) internal view returns (uint256, bool) {\n        Samurai storage attackerSamurai = samurais[_attacker];\n        Samurai storage defenderSamurai = samurais[_defender];\n        \n        // Calculate base damage\n        uint256 damage = (attackerSamurai.strength > defenderSamurai.defense / 2) ? \n            attackerSamurai.strength - (defenderSamurai.defense / 2) : 1;\n        \n        // Add randomness (0-20% bonus)\n        damage = damage + (damage * (uint256(keccak256(abi.encodePacked(block.timestamp, _attacker))) % 21)) / 100;\n        \n        // Check for critical hit\n        bool isCriticalHit = (uint256(keccak256(abi.encodePacked(block.timestamp, _attacker, \"critical\"))) % 100) < (attackerSamurai.speed * 2);\n        \n        if (isCriticalHit) {\n            // Critical hit: 150% damage + extra randomness (0-50%)\n            damage = (damage * 150) / 100 + (damage * (uint256(keccak256(abi.encodePacked(block.timestamp, _attacker, \"crit_bonus\"))) % 51)) / 100;\n        }\n        \n        return (damage, isCriticalHit);\n    }\n\n    /// @notice Ends a battle and distributes rewards\n    /// @param _battleId The ID of the battle\n    function endBattle(uint256 _battleId) internal {\n        Battle storage battle = battles[_battleId];\n        address winner = (battle.challengerHealth > 0) ? battle.challenger : battle.opponent;\n        address loser = (winner == battle.challenger) ? battle.opponent : battle.challenger;\n        \n        // Update battle stats\n        samurais[winner].battlesWon++;\n        samurais[loser].battlesLost++;\n        \n        // Award experience and check for level up\n        awardExperience(winner, 50);\n        awardExperience(loser, 10);\n        \n        // Calculate winnings and ensure contract has enough funds\n        uint256 winnings = battle.bet * 2;\n        uint256 availableFunds = address(this).balance;\n        \n        if (availableFunds >= winnings) {\n            // Full payout\n            payable(winner).transfer(winnings);\n            emit BattleEnded(_battleId, winner, loser, winnings);\n        } else {\n            // Partial payout if contract doesn't have enough funds\n            payable(winner).transfer(availableFunds);\n            emit BattleEnded(_battleId, winner, loser, availableFunds);\n        }\n        \n        battle.isActive = false;\n    }\n\n    /// @notice Awards experience points and handles level ups\n    /// @param _player The player to award experience to\n    /// @param _xp The amount of experience to award\n    function awardExperience(address _player, uint256 _xp) internal {\n        Samurai storage samurai = samurais[_player];\n        samurai.experience += _xp;\n        \n        // Check for level up\n        uint256 requiredXP = samurai.level * XP_PER_LEVEL;\n        if (samurai.experience >= requiredXP) {\n            samurai.level++;\n            samurai.skillPoints += SKILL_POINTS_PER_LEVEL;\n            samurai.experience -= requiredXP;\n        }\n    }\n\n    /// @notice Gets a player's Samurai data\n    /// @param _player The player address\n    /// @return The Samurai struct\n    function getSamurai(address _player) public view returns (Samurai memory) {\n        return samurais[_player];\n    }\n\n    /// @notice Gets battle data\n    /// @param _battleId The battle ID\n    /// @return The Battle struct\n    function getBattle(uint256 _battleId) public view returns (Battle memory) {\n        return battles[_battleId];\n    }\n\n    /// @notice Gets the contract owner address\n    /// @return The owner address\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    /// @notice Allows the owner to withdraw contract funds\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds to withdraw\");\n        payable(owner).transfer(balance);\n    }\n\n    /// @notice Allows the owner to fund the contract for battle rewards\n    function fundContract() public payable onlyOwner {\n        require(msg.value > 0, \"Must send funds to contract\");\n        emit ContractFunded(msg.sender, msg.value);\n    }\n\n    /// @notice Allows the contract to receive ETH\n    receive() external payable {\n        // Contract can receive ETH for battle funding\n    }\n}"
      }
    }
  }
}